JAVATPOINT


String

There are two ways to create String object:

String is class NOT A DATATYPE !! String is Non primitive data type
String is not mutable class
By string literal(constant pool): Each time you create a string literal, the JVM checks the "string constant pool" first. If the string already exists in the pool, a reference to the pooled instance is returned. If the string doesn't exist in the pool, a new string instance is created and placed in the pool.
String str= "Hi"; (constant pool)

By new keyword(non constant pool/heap memory): In such case, JVM will create a new string object in normal (non-pool) heap memory, and the literal "Welcome" will be placed in the string constant pool. The variable s will refer to the object in a heap (non-pool).
String str = new String("Hi"); (heap memory)


Java BufferedReader class is used to read the text from a character-based input stream. It can be used to read data line by line by readLine() method. It makes the performance fast. It inherits Reader class.

StringBuffer is synchronized i.e. thread safe. It means two threads can't call the methods of StringBuffer simultaneously.
StringBuffer is less efficient than StringBuilder.
stringBuffer is mutable class
StringBuffer was introduced in Java 1.0

StringBuilder is non-synchronized i.e. not thread safe. It means two threads can call the methods of StringBuilder simultaneously.
StringBuilder is more efficient than StringBuffer.
StringBuilder is mutable class
StringBuilder was introduced in Java 1.5

HashMap is non synchronised & not thread safe
HashTable is synchrosied & thread safe

----------------------------------------------------------------------------------------

OOPS:
1)OOPs makes development and maintenance easier, whereas, in a procedure-oriented programming language, it is not easy to manage if code grows as project size increases.

2) OOPs provides data hiding, whereas, in a procedure-oriented programming language, global data can be accessed from anywhere.

Object
Any entity that has state and behavior is known as an object. For example, a chair, pen, table, keyboard, bike, etc. It can be physical or logical
----------------------------------------------------------------------------------------
Class
A class can also be defined as a blueprint from which you can create an individual object. Class doesn't consume any space.
----------------------------------------------------------------------------------------
Inheritance
When one object acquires all the properties and behaviors of a parent object, it is known as inheritance.
you can reuse methods and fields of the parent class +  add new methods and fields in your current class also.
It provides code reusability.
It is used to achieve runtime polymorphism.
***EXAMPLES: Base class is drived in test cases class

>>Multiple inheritance is not supported in Java through class.
Consider a scenario where A, B, and C are three classes. The C class inherits A and B classes. If A and B classes have the same method and you call it from child class object, there will be ambiguity to call the method of A or B class.

types:
Single inheritance
Multiple Inheritance
Multi-level Inheritance

Hierarchical Inheritance
Hybrid Inheritance

----------------------------------------------------------------------------------------
ABSTRACTION

Hiding internal details and showing functionality. For example phone call, we don't know the internal processing.
example: POM: Page object stored in diff class and used in TC. @FindBy anotation used in Page Object Model. it hides the internal functionality and works as driver.findElement

----------------------------------------------------------------------------------------
There are two ways to achieve abstraction in java:
Abstract class (0 to 100%)
Interface (100%)

Points to Remember
An abstract class must be declared with an abstract keyword.
It can have abstract and non-abstract methods.
It cannot be instantiated.
[]--It can have constructors and static methods, final methods also.
If there is an abstract method in a class, that class must be abstract.
If you are extending an abstract class that has an abstract method, you must either provide the implementation of the method or make this class abstract.

Shape is the abstract class, and its implementation is provided by the Rectangle and Circle classes.


----------------------------------------------------------------------------------------
>>The Method with Final Keyword cannot be overridden in the subclasses. 
>>The purpose of the Final Method is to declare methods of how’s definition can not be changed by a child or subclass that extends it.
----------------------------------------------------------------------------------------

INTERFACE
Hiding internal details and showing functionality.
is a blueprint of a class. It has public static final constants and abstract methods.
is used to achieve abstraction.
is used to achieve multiple inheritance

examples: WebDriver dirver = new Chromdriver();
TContants carries all the constants

public static final <variableName>   -- JVM automaticaly adds public, static and final keywords before data members.
public static fnal <variableName>

public abstract  void <methodName>();	--no body.The Java compiler adds public and abstract keywords before the interface method.
public abstract  void <methodName>();	--nod body. The Java compiler adds public and abstract keywords before the interface method.

There are mainly three reasons to use interface. They are given below.
-It is used to achieve abstraction.
-By interface, we can support the functionality of multiple inheritance(implementation is provided by the implementation class)
-It can be used to achieve loose coupling.

If a class implements multiple interfaces, or an interface extends multiple interfaces, it is known as multiple inheritance.

However, mukltiple inheritance is supported in case of an interface because there is no ambiguity. It is because its implementation is provided by the implementation class.


----------------------------------------------------------------------------------------

Encapsulation(provides the data hiding/control over the data members/maintain the data integrity)
Binding (or wrapping) code and data together into a single unit are known as encapsulation. For example, a capsule, it is wrapped with different medicines.

HOW WE CAN ACHIEVE:
We can create a fully encapsulated class in Java by making 
-all the data members of the class private. 
-Now we can use setter and getter methods to set and get the data in it.

-set private data members
-setter and getter methods to get set value of data member

example: POJO(Plain Old Java Object) Classes. all data memebrs/variables are with private access modifier. And all methods are of getter and setter methods
ADVANTANGES:
[]--It provides you the control over the data.
[DATA HIDING]--It is a way to achieve data hiding in Java because other class will not be able to access the data through the private data members.
----------------------------------------------------------------------------------------

 It maintains data integrity.

Data hiding means hiding the internal data within the class to prevent its direct access from outside the class.

If we talk about data encapsulation so, Data encapsulation hides the private methods and class data parts, whereas Data hiding only hides class data components. Both data hiding and data encapsulation are essential concepts of object-oriented programming.
----------------------------------------------------------------------------------------

POLYMORPHISM
Polymorphism in Java is a concept by which we can perform a single action in different ways with different data or different requirements.

HOW WE CAN ACHIEVE:
In Java, we use method overloading and method overriding to achieve polymorphism.

METHOD OVERLOADING/COMPILE TIME POLY/EARLY BINDING/STATIC BINDING ::
If a class has multiple methods having same name but different in parameters or different in parameter type, it is known as Method Overloading.
There are two ways to overload the method in java
By changing number of arguments
By changing the data type of arguments
it do not depends on the method return type
ADVANTAGES:
Method overloading increases the readability of the program.

Note:Overloaded methods may have the same or different return types, but they must differ in parameters.

[][]--static method and consultructor can overload
[]--It is not method overloading if we only change the return type of methods. There must be differences in the number of parameters.

[]--Yes, by method overloading. You can have any number of main methods in a class by method overloading. But JVM
calls main() method which receives string array as arguments only.

example: implicit waits. driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS ||  Duration.ofSeconds(5)) --SECONDS, MINUTES, HOURS

Method Overloading(perform same action with different data type [readability]):
Method overloading increases the readability of the program. 
This provides flexibility to programmers so that they can call the same method for different types of data.
----------------------------------------------------------------------------------------


METHOD OVERRIDING/RUNTIME POLY

If subclass (child class) has the same method as declared in the parent class, it is known as method overriding in Java.
if the same method is defined in both the superclass and the subclass, then the method of the subclass class overrides the method of the superclass. This is known as method overriding.

[]--@Override annotation specifies the compiler that the method after this annotation overrides the method of the superclass.
[]--It is not mandatory to use @Override. However, when we use this, the method should follow all the rules of overriding. Otherwise, the compiler will generate an error.

Rules:
-Both the superclass and the subclass must have the same method name, the same return type and the same parameter list.
[]--We cannot override the method declared as final and static.

-We should always override abstract methods of the superclass

[]--To access the method of the superclass from the subclass, we use the super keyword. ex: super().<superclassmethodName>;

[]--It is important to note that constructors in Java are not inherited. Hence, there is no such thing as constructor overriding in Java.
Runtime polymorphism or Dynamic Method Dispatch is a process in which a call to an overridden method is resolved at runtime rather than compile-time.
[]--We can only use those access specifiers in subclasses that provide larger access than the access specifier of the superclass.
[]--a method myClass() in the superclass is declared protected. Then, the same method myClass() in the subclass can be either public or protected, but not private.

[][]--static(main method) and contsructor, final cannot be override(WHY BECAUSE STATIC IS BIND TO CLASS + CONSTRUCTOR NAME IS SAME AS CLASS)
[][]--static method and consultructor can overload

example: methods present in Webdriver interface are defined in subclass.

Method Overrding(override[implement it's own functionality accroding to the req] the functionality of an existing method):
ADVANTAGE
ability to define a behavior that's specific to the subclass type, which means a subclass can implement a parent class method based on its requirement. In object-oriented terms, overriding means to override the functionality of an existing method.
-Overriden- method in superclass
-Ovcerrding - method in subclass

----------------------------------------------------------------------------------------


Constructor:
A constructor is used to initialize the state of an object.
a constructor is a block of codes similar to the method. It is called when an instance of the class is created. 
At the time of calling constructor, memory for the object is allocated in the memory.
The constructor is invoked implicitly.
-It is a special type of method which is used to initialize the object.
-Every time an object is created using the new() keyword, at least one constructor is called.
-It is called constructor because it constructs the values at the time of object creation. It is not necessary to write a constructor for a class. It is because java compiler creates a default constructor if your class doesn't have any.
-Constructor name must be the same as its class name
-A Constructor must have no explicit return type
[]-A Java constructor cannot be abstract, static, final, and synchronized
[]-while declaring a constructor. It controls the object creation. In other words, we can have private, protected, public or default constructor in Java.
-The default constructor is used to provide the default values to the object like 0, null, etc., depending on the type.

-A constructor which has a specific number of parameters is called a parameterized constructor.
-The parameterized constructor is used to provide different values to distinct objects. However, you can provide the same values also
-In Java, a constructor is just like a method but without return type. It can also be overloaded like Java methods.
-Constructor overloading in Java is a technique of having more than one constructor with different parameter lists. They are arranged in a way that each constructor performs a different task. They are differentiated by the compiler by the number of parameters in the list and their types.
----------------------------------------------------------------------------------------

STATIC
The static keyword in Java is used for memory management mainly OR saving the memory. 
The static keyword belongs to the class than an instance of the class.
The static variable gets memory only once in the class area at the time of class loading.
It considers as  class members 
we can access them without creating object. THAT IS WHY WE USE PSUBLIC STATIC VOID MAIN() METHOD WITH STATIS BEACUSE WE DONT NEED TO CREATE OBJECT TO CALL MAIN METHOD
we dont need to create data memeber again and again if data memeber is common to all like employee name, college name
it automatically initialised to 0
static block will execute before the main method. WHY BEACUASE it is used to insialixe the data members.

The static can be:
Variable (also known as a class variable)
Method (also known as a class method)
Block
Nested clas

EXAMPLE: we put webdriver driver interface as static, so that it can share with all the java classes instead of initilaisaing in every class. 
We also put constants as static 
>>static contanst in Automation framework, so that we can use them across the frameowkr
>> static methods of utility class, to call them across the framework

\VARIABLE
The static variable can be used to refer to the common property of all objects (which is not unique for each object), for example, the company name of employees, college name of students, etc. EXAMPLES: XPATH OF WEBELEMENT IS STATIC WHICH IS SHARED BY ALL CLASSES.
The static variable gets memory only once in the class area at the time of class loading.
It makes your program memory efficient (i.e., it saves memory).
Java static property is shared to all objects.

METHOD
A static method belongs to the class rather than the object of a class.
A static method can be invoked without the need for creating an instance of a class.
A static method can access static data member and can change the value of it.

[]--The static method can not use non static data member or call non-static method directly.
[]--this and super cannot be used in static context.

Why is the Java main method static?
Ans) It is because the object is not required to call a static method. If it were a non-static method, JVM creates an object first then call main() method that will lead the problem of extra memory allocation.

[]--static method can be overloaded but do not overrdie

STATIC BLOCK
Is used to initialize the static data member.
It is executed before the main method at the time of classloading.
----------------------------------------------------------------------------------------


FINAL
The final keyword in java is used to restrict the user. The java final keyword can be used in many context. Final can be:

variable
method
class

final is the keyword and access modifier which is used to apply restrictions on a class, method or variable.

(1) Once declared, final variable becomes constant and cannot be modified.
(2) final method cannot be overridden by sub class.
(3) final class cannot be inherited.

FINALISE
used to perform clean up activities just before object is garbage collected.

protected void finalize() throws Throwable  


FINALLy
(1) finally block runs the important code even if exception occurs or not.
(2) finally block cleans up all the resources used in try block
finally defines a block of code we use along with the try keyword. It defines code that's always run after the try and any catch block, before the method is completed.

The finally block executes regardless of whether an exception is thrown or caught.
finally {
    System.out.println("In finally");
}

We generally use the finally block to execute clean up code like closing connections, closing files, or freeing up threads, as it executes regardless of an exception.

----------------------------------------------------------------------------------------
Wrapper class in java are used for data conversion. In data conversion if user wants to convert 
Int to string, 
String to int, 
Boolean, double then we use Wrapper class. 
integer.parseInt(); - To convert string to Integer
Double.parseDouble(); - To convert string to Double
Boolean.parse Boolean(); - To convert string to Boolean
String.valueof(); - To convert Integer to String.

------------------------------
order of annotation
@BeforeSuite
 @BeforeTest
 @BeforeClass
 @BeforeMethod
 @Test
 @AfterMethod
 @AfterClass
 @AfterTest
@AfterSuite

-----------------------------



The java.lang.Throwable class is the root class of Java Exception hierarchy inherited by two subclasses: Exception and Error.
three types of exception:
Checked Exception
Unchecked Exception
Error

1) Checked Exception(use throws with method signature)
The classes that directly inherit the Throwable class except RuntimeException and Error are known as checked exceptions. For example, IOException, SQLException, etc. Checked exceptions are checked at compile-time.
[]--Checked exception is handled during compile time and it gives the compilation error if it is not caught and handled during compile time.

Example: FileNotFoundException, IOException, 

2) Unchecked Exception
The classes that inherit the RuntimeException are known as unchecked exceptions. For example, ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException, etc. Unchecked exceptions are not checked at compile-time, but they are checked at runtime.
[]--In case of the unchecked exception, a compiler does not mandate to handle. The compiler ignores during compile time.

Example: ArrayIndexoutOfBoundException, ArithmeticException, NullPointerException, 

3) Error
Error is irrecoverable. Some example of errors are OutOfMemoryError, VirtualMachineError, AssertionError etc.
When a scenario is fatal and the program cannot recover then JVM throws an error. Errors cannot be handled by the try-catch block. Even if the user tries to handle the error by using Try catch block, it cannot recover from the error.

Example: Assertion error, OutOfMemoryError etc.
-------------------------------------------------------------------------------
Though there are many Exception classes under WebDriverException, we commonly see the below ones.

-NoSuchElementException
-NoSuchWindowException
NoSuchFrameException
NoAlertPresentException
InvalidSelectorException
ElementNotVisibleException
ElementNotSelectableException
TimeoutException
NoSuchSessionException
StaleElementReferenceException
WebDriverException: Exception comes when a code is unable to initialize WebDriver.

ElementNotInteractableException − It is thrown if a webelement is attached to the DOM, but on trying to access the same webelement a different webelement gets accessed.
ElementClickInterceptedException − It is thrown if a click operation on a webelement could not happen because another webelement covering that webelement receives the click.
ElementNotVisibleException − It is thrown if a webelement is attached to the DOM, but invisible on the page and inaccessible.
ElementNotSelectableException − It is thrown if we make an attempt to select a webelement which is not selectable.
ImeActivationFailedException − It is thrown if we fail to activate an IME engine.
ErrorInResponseException − It is thrown if there is an issue on the server side.
InsecureCertificateException − It is thrown if a user gets a certificate warning while navigating an application. It is due to a TLS certificate which is no longer active and valid.
ImeNotAvailableException − It is thrown if there is no support for the IME engine.
InvalidCookieDomainException − It is thrown if we try to add a cookie under a varied domain than the present URL.
InvalidArgumentException − It is thrown if the argument passed to a command is no longer valid.
InvalidElementStateException − It is thrown if we try to access a webelement which is not in a valid state.
InvalidCoordinatesException − It is thrown if the coordinates for interactions are not valid.
InvalidSessionIdException − It is thrown if the session id is not available in the group of live sessions. Thus the given session is either non-existent or inactive.
InvalidSelectorException − It is thrown if the locator used to identify an element does not yield a webelement.
MoveTargetOutOfBoundsException − It is thrown if the target given in the ActionChains method is out of the scope of the document.
InvalidSwitchToTargetException − It is thrown if the frame id/name or the window handle id to be switched to is incorrect.
NoSuchAttributeException − It is thrown if an element attribute is not detected.
NoAlertPresentException − It is thrown if we try to switch to an alert which is non-existent.
NoSuchFrameException − It is thrown if we try to switch to a frame which is non-existent.
StaleElementReferenceException − It is thrown if an element reference is currently stale.
NoSuchWindowException − It is thrown if we try to switch to a window which is non-existent.
UnexpectedAlertPresentException − It is thrown if an alert appears unexpectedly in an automation flow.
UnableToSetCookieException − It is thrown if the webdriver is unsuccessful in setting a cookie.
UnexpectedTagNameException − It is thrown if a support class has not received an anticipated webelement.
NoSuchElementException − It is thrown if the selector used is unable to locate a webelement.

----------------------------------------------------------------------------------------
The "throw" keyword is used to throw an exception.

The "throws" keyword is used to declare exceptions. (use with checked exceptions)
It specifies that there may occur an exception in the method. 
It doesn't throw an exception. 
It is always used with method signature.
----------------------------------------------------------------------------------------

Call by Value means calling a method with a parameter as value. Through this, the argument value is passed to the parameter.

While Call by Reference means calling a method with a parameter as a reference. Through this, the argument reference is passed to the parameter.
----------------------------------------------------------------------------------------

difference in Array and Arraylist
Array 
An array is a dynamically-created object. It serves as a container that holds the constant number of values of the same type. It has a contiguous memory location
Array is static in size.
An array is a fixed-length data structure.
It is mandatory to provide the size of an array while initializing it directly or indirectly.
It performs fast in comparison to ArrayList because of fixed size.
We use for loop or for each loop to iterate over an array.
Array can be multi-dimensional.
We can add elements in an array by using the assignment operator.

ArrayList
The ArrayList is a class of Java Collections framework. It contains popular classes like Vector, HashTable, and HashMap.
ArrayList is dynamic in size.
ArrayList is a variable-length data structure. It can be resized itself when needed.
We can create an instance of ArrayList without specifying its size. Java creates ArrayList of default size.
ArrayList is internally backed by the array in Java. The resize operation in ArrayList slows down the performance.
We use an iterator to iterate over ArrayList.
ArrayList is always single-dimensional.
Java provides the add() method to add elements in the ArrayList.
-------------------------------------------------------------------------------------
https://www.javatpoint.com/access-modifiers

	withinclass	withinpackage	outsidepackagebysubclassonly	outsidepackage
Private	  Y		     N		N				N
Default	  Y		     Y		N				N
Protected 	  Y		     Y		Y				N
Public	  Y		     Y		Y				Y


----------------------------------------------------------------------------------------


COLLECTIONS:

Java HashMap class implements the Map interface which allows us to store key and value pair, where keys should be unique. If you try to insert the duplicate key, it will replace the element of the corresponding key. It is easy to perform operations using the key index like updation, deletion, etc. HashMap class is found in the java.util package.
HashMap in Java is like the legacy Hashtable class, but it is not synchronized. It allows us to store the null elements as well, but there should be only one null key.

Points to remember
Java HashMap contains values based on the key.
Java HashMap contains only unique keys.
[]--Java HashMap may have one null key and multiple null values.
Java HashMap is non synchronized.
[]--Java HashMap maintains no order.

-------------------------------------------------------------------------------------------
LIST {ArrayList, LinkedList}
ordered collection
It contains the index-based methods to insert, update, delete and search the elements.
have the duplicate elements also. We can also store the null elements in the list.
The List interface is found in the java.util package and inherits the Collection interface.
The implementation classes of List interface are ArrayList, LinkedList, Stack and Vector(The Vector class is deprecated since Java 5.)
List is an interface whereas ArrayList is the implementation class of List.
List allows us to add any number of null values.

We can get the element of a specified index from the list using the get() method.
[]--It is used when we want to frequently access the elements by using the index.
The method of List interface listiterator() is used to iterate the List elements.

----------------------------------------------------------------------------------------
SET {TreeSet, HashSet and LinkedHashSet.}
The set is an interface available in the java.util package. The set interface extends the Collection interface.
An unordered collection or list in which duplicates are not allowed is referred to as a collection interface. The set interface is used to create the mathematical set. The set interface use collection interface's methods to avoid the insertion of the same elements. SortedSet and NavigableSet are two interfaces that extend the set implementation.
[]--Set allows us to add at least one null value in it.
The Set implementation classes are TreeSet, HashSet and LinkedHashSet.
We cannot find the element from the Set based on the index because it doesn't provide any get method().
[]--It is used when we want to design a collection of distinct elements.
The iterator is used when we need to iterate the Set elements.

 	Set<Integer> set1 = new HashSet<Integer>();    
        set1.addAll(Arrays.asList(A));  
  
        Set<Integer> set2 = new HashSet<Integer>();   

----------------------------------------------------------------------------------------

we read and write on Excel file with the help of Java IO package and Apache POI library.
To read XLS files, an HSSF implementation is provided by POI library.

To read XLSX, XSSF implementation of POI library will be the choice.


Read
File file =    new File(filePath+"\\"+fileName);
FileInputStream inputStream = new FileInputStream(file);
Workbook guru99Workbook = new XSSFWorkbook(inputStream);

Sheet guru99Sheet = guru99Workbook.getSheet(sheetName);
 int rowCount = guru99Sheet.getLastRowNum()-guru99Sheet.getFirstRowNum();

 Row row = guru99Sheet.getRow(i);


            //Print Excel data in console

            System.out.print(row.getCell(j).getStringCellValue()+"|| ");

Read data
.getRow(1);
.getCell(1);

Write data
.createRow(1)
.createCell(1);

----------------------------------------------------------------------------------------
write 

Row newRow = sheet.createRow(rowCount+1);
Cell cell = newRow.createCell(j);

cell.setCellValue(dataToWrite[j]);
----------------------------------------------------------------------------------------

public static void main(String args[])

PUBLIC(access from anywhere)
It is an Access modifier, which specifies from where and who can access the method. Making the main() method public makes it globally available. It is made public so that JVM can invoke it from outside the class as it is not present in the current class.

STATIC(call without any object creation)
It is a keyword that is when associated with a method, making it a class-related method. The main() method is static so that JVM can invoke it without instantiating the class. This also saves the unnecessary wastage of memory which would have been used by the object declared only for calling the main() method by the JVM.

VOID (no return type)
It is a keyword and is used to specify that a method doesn’t return anything. As the main() method doesn’t return anything, its return type is void. 

MAIN(method name)
It is the name of the Java main method. It is the identifier that the JVM looks for as the starting point of the java program. It’s not a keyword.

STRING [] ARGS(comman line argumnet)
It stores Java command-line arguments and is an array of type java.lang.String class. Here, the name of the String array is args but it is not fixed and the user can use any name in place of it. 

----------------------------------------------------------------------------------------

JVM
-is an abstract machine. 
-provides runtime environment in which java bytecode can be executed.
-JVM is platform dependent

perform following operations:
-Loads code
-Verifies code
-Executes code
-Provides runtime environment
----------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------
Customize Exception(can create with extends Exception class): In Java, we can create our own exceptions that are derived classes of the Exception class. Creating our own Exception is known as custom exception or user-defined exception. Basically, Java custom exceptions are used to customize the exception according to user need.

public class WrongFileNameException extends Exception {  
    public WrongFileNameException(String errorMessage) {  
    super(errorMessage);  
    }  
}  



----------------------------------------------------------------------------------------

Java8 features:
-forEach(): Java provides a new method forEach() to iterate the elements. It is defined in Iterable and Stream interfaces.
-Date/Time API: Java has introduced a new Date and Time API since Java 8. The java.time package contains Java 8 Date and Time classes.
-default and static methods in Interfaces.

----------------------------------------------------------------------------------------
Exception Handling
is one of the powerful mechanism to handle the runtime errors so that the normal flow of the application can be maintained.
The java.lang.Throwable class is the root class of Java Exception hierarchy inherited by two subclasses: Exception and Error.

try{}
catch(Exception e)
{}
catch(ArithmeticException e)
{}
catch(ArrayIndexOutOfBoundsException e)
{}
finally{}

NOTE: we can implement multiple catch blocks.

----------------------------------------------------------------------------------------

Runtime data area in JVM can be divided as below:
Method Area : Storage area for compiled class files. (One per JVM instance)

Heap Memory(Objects, Static variables) : Storage area for Objects. (One per JVM instance). After the java 8 version, static variables are stored in the heap memory.

Java stack(local variables, refernce variables): Storage area for local variables,  local variables and reference variables,  results of intermediate operations. (One per thread)

PC Register : Stores the address of the next instruction to be executed if the next instruction is native method then the value in pc register will be undefined. (One per thread)

Native method stacks : Helps in executing native methods (methods written in languages other than Java). (One per thread)

----------------------------------------------------------------------------------------
Thread
A thread in Java is the direction or path that is taken while a program is being executed. Generally, all the programs have at least one thread, known as the main thread, that is provided by the JVM or Java Virtual Machine at the starting of the program's execution.
ADANTAGE
Threads allows a program to operate more efficiently by doing multiple things at the same time.
we can define threads as a subprocess with lightweight with the smallest unit of processes and also has separate paths of execution. These threads use shared memory but they act independently hence if there is an exception in threads that do not affect the working of other threads despite them sharing the same memory. 

Threads can be used to perform complicated tasks in the background without interrupting the main program.

Java offers two types of threads:

-User threads- are high-priority threads. The JVM will wait for any user thread to complete its task before terminating it.
-daemon threads- are low-priority threads whose only role is to provide services to user threads.

----------------------------------------------------------------------------------------
Multithreading/Thread-based Multitasking(saves time, execute in parallel, shared same memory, error in one thread do not affect other)

-Multithreading in Java is a process of executing multiple threads simultaneously.
-A thread is a lightweight sub-process, the smallest unit of processing. 
-Threads share the same address space.
-Cost of communication between the thread is low.
-Threads are independent. If there occurs exception in one thread, it doesn't affect other threads. It uses a shared memory area.

-Multiprocessing and multithreading, both are used to achieve multitasking.
-However, we use multithreading than multiprocessing because threads use a shared memory area. They don't allocate separate memory area so saves memory, and context-switching between the threads takes less time than process.

Ex: Java Multithreading is mostly used in games, animation, etc.

Advantages:
-You can perform many operations together, so it saves time.
-Threads are independent, so it doesn't affect other threads if an exception occurs in a single thread.

----------------------------------------------------------------------------------------

Multiprocessing/ Process-based Multitasking (each process has its own memory)
-Each process has an address in memory. In other words, each process allocates a separate memory area.
-A process is heavyweight.
-Cost of communication between the process is high.
-Switching from one process to another requires some time for saving and loading registers, memory maps, updating lists, etc.

----------------------------------------------------------------------------------------

Synchronous (Classic Web-Application Model)(one task at a time)
-A synchronous request blocks the client until operation completes i.e. browser is unresponsive. In such case, javascript engine of the browser is blocked.
-we can execute one task at a time,

Asynchronous (AJAX Web-Application Model)(multiple task at the same time)
-An asynchronous request doesn’t block the client i.e. browser is responsive. At that time, user can perform another operations also. In such case, javascript engine of the browser is not blocked.
-we can execute multiple tasks at the same time.

----------------------------------------------------------------------------------------
Packages
A java package is a group of similar types of classes, interfaces and sub-packages.
two types:
-built-in package:  such as java, lang, awt, javax, swing, net, io, util, sql etc.
-user-defined package.

advantages:
-Java package is used to categorize the classes and interfaces so that they can be easily maintained.
-Java package provides access protection.
-Java package removes naming collision.

syntax: package pack; 

There are three ways to access the package from outside the package.
import package.*;
import package.classname;
fully qualified name.

----------------------------------------------------------------------------------------

Namespace(used in C++)
 is used as additional information to differentiate similar functions, classes, variables etc. with the same name available in different libraries. Using namespace, you can define the context in which names are defined. In essence, a namespace defines a scope.
----------------------------------------------------------------------------------------

String declaration;
String initialization = "initialization";
declaration = "assignment";

----------------------------------------------------------------------------------------

Java Module System is a major change in Java 9 version. Java added this feature to collect Java packages and code into a single unit called module.

----------------------------------------------------------------------------------------

Collections

A Java collection framework provides an architecture to store and manipulate a group of objects. A Java collection framework includes the following:

Interfaces
Classes
Algorithm

----------------------------------------------------------------------------------------
ARRAYLIST
ArrayList is the implementation of List Interface where the elements can be dynamically added or removed from the list.
Also, the size of the list is increased dynamically if the elements are added more than the initial size. 

ArrayList object = new ArrayList ();

LINKEDLIST
Linked List: Linked List is a sequence of links which contains items. Each link contains a connection to another link.

Linkedlist object = new Linkedlist();

Java Linked List class uses two types of Linked list to store the elements:

Singly Linked List: Singly Linked List: In a singly Linked list each node in this list stores the data of the node and a pointer or reference to the next node in the list. 


Doubly Linked List : In a doubly Linked list, it has two references, one to the next node and another to previous node. 


Queue
Queue in Java follows a FIFO approach i.e. it orders the elements in First In First Out manner. In a queue, the first element is removed first and last element is removed in the end. Each basic method exists in two forms: one throws an exception if the operation fails, the other returns a special value.
Also, priority queue implements Queue interface. The elements of the priority queue are ordered according to their natural ordering, or by a Comparator provided at the queue construction time. The head of this queue is the least element with respect to the specified ordering.


SET
A Set refers to a collection that cannot contain duplicate elements. It is mainly used to model the mathematical set abstraction. Set has its implementation in various classes such as HashSet, TreeSetand LinkedHashSet.

HashSet: Java HashSet class creates a collection that use a hash table for storage. Hashset only contain unique elements and it inherits the AbstractSet class and implements Set interface. Also, it uses a mechanism hashing to store the elements.  


Linked Hashset : Java LinkedHashSet class is a Hash table and Linked list implementation of the set interface. It contains only unique elements like HashSet. Linked HashSet also provides all optional set operations and maintains insertion order. 

TreeSet : TreeSet class implements the Set interface that uses a tree for storage. The objects of this class are stored in the ascending order. Also, it inherits AbstractSet class and implements NavigableSet interface. It contains only unique elements like HashSet. In TreeSet class, access and retrieval time are faster.

https://www.edureka.co/blog/java-collections/


